[
  {
    "functions_documentation": {
      "extraction_timestamp": "2025-07-13T12:36:43.921055+00:00",
      "database": "postgres",
      "summary": {
        "total_functions": 107,
        "total_procedures": 0,
        "by_schema": {
          "extensions": {
            "total": 55,
            "functions": 55,
            "procedures": 0
          },
          "auth": {
            "total": 4,
            "functions": 4,
            "procedures": 0
          },
          "vault": {
            "total": 5,
            "functions": 5,
            "procedures": 0
          },
          "storage": {
            "total": 10,
            "functions": 10,
            "procedures": 0
          },
          "graphql_public": {
            "total": 1,
            "functions": 1,
            "procedures": 0
          },
          "graphql": {
            "total": 6,
            "functions": 6,
            "procedures": 0
          },
          "pgbouncer": {
            "total": 1,
            "functions": 1,
            "procedures": 0
          },
          "realtime": {
            "total": 12,
            "functions": 12,
            "procedures": 0
          },
          "public": {
            "total": 13,
            "functions": 13,
            "procedures": 0
          }
        },
        "by_language": {
          "c": 53,
          "plpgsql": 41,
          "sql": 13
        }
      },
      "functions_list": [
        {
          "schema": "auth",
          "name": "email",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "text",
          "language": "sql",
          "volatility": "STABLE",
          "security_definer": false,
          "comment": "Deprecated. Use auth.jwt() -> 'email' instead.",
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n"
        },
        {
          "schema": "auth",
          "name": "jwt",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "jsonb",
          "language": "sql",
          "volatility": "STABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n"
        },
        {
          "schema": "auth",
          "name": "role",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "text",
          "language": "sql",
          "volatility": "STABLE",
          "security_definer": false,
          "comment": "Deprecated. Use auth.jwt() -> 'role' instead.",
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n"
        },
        {
          "schema": "auth",
          "name": "uid",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "uuid",
          "language": "sql",
          "volatility": "STABLE",
          "security_definer": false,
          "comment": "Deprecated. Use auth.jwt() -> 'sub' instead.",
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n"
        },
        {
          "schema": "extensions",
          "name": "armor",
          "type": "FUNCTION",
          "arguments": "bytea",
          "return_type": "text",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_armor"
        },
        {
          "schema": "extensions",
          "name": "armor",
          "type": "FUNCTION",
          "arguments": "bytea, text[], text[]",
          "return_type": "text",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_armor"
        },
        {
          "schema": "extensions",
          "name": "crypt",
          "type": "FUNCTION",
          "arguments": "text, text",
          "return_type": "text",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_crypt"
        },
        {
          "schema": "extensions",
          "name": "dearmor",
          "type": "FUNCTION",
          "arguments": "text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_dearmor"
        },
        {
          "schema": "extensions",
          "name": "decrypt",
          "type": "FUNCTION",
          "arguments": "bytea, bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_decrypt"
        },
        {
          "schema": "extensions",
          "name": "decrypt_iv",
          "type": "FUNCTION",
          "arguments": "bytea, bytea, bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_decrypt_iv"
        },
        {
          "schema": "extensions",
          "name": "digest",
          "type": "FUNCTION",
          "arguments": "text, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_digest"
        },
        {
          "schema": "extensions",
          "name": "digest",
          "type": "FUNCTION",
          "arguments": "bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_digest"
        },
        {
          "schema": "extensions",
          "name": "encrypt",
          "type": "FUNCTION",
          "arguments": "bytea, bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_encrypt"
        },
        {
          "schema": "extensions",
          "name": "encrypt_iv",
          "type": "FUNCTION",
          "arguments": "bytea, bytea, bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_encrypt_iv"
        },
        {
          "schema": "extensions",
          "name": "gen_random_bytes",
          "type": "FUNCTION",
          "arguments": "integer",
          "return_type": "bytea",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_random_bytes"
        },
        {
          "schema": "extensions",
          "name": "gen_random_uuid",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "uuid",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_random_uuid"
        },
        {
          "schema": "extensions",
          "name": "gen_salt",
          "type": "FUNCTION",
          "arguments": "text",
          "return_type": "text",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_gen_salt"
        },
        {
          "schema": "extensions",
          "name": "gen_salt",
          "type": "FUNCTION",
          "arguments": "text, integer",
          "return_type": "text",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_gen_salt_rounds"
        },
        {
          "schema": "extensions",
          "name": "grant_pg_cron_access",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "event_trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": "Grants access to pg_cron",
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequence...[truncated]"
        },
        {
          "schema": "extensions",
          "name": "grant_pg_graphql_access",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "event_trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": "Grants access to pg_graphql",
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n    ...[truncated]"
        },
        {
          "schema": "extensions",
          "name": "grant_pg_net_access",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "event_trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": "Grants access to pg_net",
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    IF NOT EXISTS (\n      SELECT 1\n      FROM pg_roles\n      WHERE rolname = 'supabase_functions_admin'\n    )\n    THEN\n      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n    END IF;\n\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;...[truncated]"
        },
        {
          "schema": "extensions",
          "name": "hmac",
          "type": "FUNCTION",
          "arguments": "bytea, bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_hmac"
        },
        {
          "schema": "extensions",
          "name": "hmac",
          "type": "FUNCTION",
          "arguments": "text, text, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_hmac"
        },
        {
          "schema": "extensions",
          "name": "pg_stat_statements",
          "type": "FUNCTION",
          "arguments": "showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision",
          "return_type": "SETOF record",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_stat_statements_1_10"
        },
        {
          "schema": "extensions",
          "name": "pg_stat_statements_info",
          "type": "FUNCTION",
          "arguments": "OUT dealloc bigint, OUT stats_reset timestamp with time zone",
          "return_type": "record",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_stat_statements_info"
        },
        {
          "schema": "extensions",
          "name": "pg_stat_statements_reset",
          "type": "FUNCTION",
          "arguments": "userid oid, dbid oid, queryid bigint",
          "return_type": "void",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pg_stat_statements_reset_1_7"
        },
        {
          "schema": "extensions",
          "name": "pgp_armor_headers",
          "type": "FUNCTION",
          "arguments": "text, OUT key text, OUT value text",
          "return_type": "SETOF record",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_armor_headers"
        },
        {
          "schema": "extensions",
          "name": "pgp_key_id",
          "type": "FUNCTION",
          "arguments": "bytea",
          "return_type": "text",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_key_id_w"
        },
        {
          "schema": "extensions",
          "name": "pgp_pub_decrypt",
          "type": "FUNCTION",
          "arguments": "bytea, bytea",
          "return_type": "text",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_pub_decrypt_text"
        },
        {
          "schema": "extensions",
          "name": "pgp_pub_decrypt",
          "type": "FUNCTION",
          "arguments": "bytea, bytea, text",
          "return_type": "text",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_pub_decrypt_text"
        },
        {
          "schema": "extensions",
          "name": "pgp_pub_decrypt",
          "type": "FUNCTION",
          "arguments": "bytea, bytea, text, text",
          "return_type": "text",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_pub_decrypt_text"
        },
        {
          "schema": "extensions",
          "name": "pgp_pub_decrypt_bytea",
          "type": "FUNCTION",
          "arguments": "bytea, bytea",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_pub_decrypt_bytea"
        },
        {
          "schema": "extensions",
          "name": "pgp_pub_decrypt_bytea",
          "type": "FUNCTION",
          "arguments": "bytea, bytea, text, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_pub_decrypt_bytea"
        },
        {
          "schema": "extensions",
          "name": "pgp_pub_decrypt_bytea",
          "type": "FUNCTION",
          "arguments": "bytea, bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_pub_decrypt_bytea"
        },
        {
          "schema": "extensions",
          "name": "pgp_pub_encrypt",
          "type": "FUNCTION",
          "arguments": "text, bytea",
          "return_type": "bytea",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_pub_encrypt_text"
        },
        {
          "schema": "extensions",
          "name": "pgp_pub_encrypt",
          "type": "FUNCTION",
          "arguments": "text, bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_pub_encrypt_text"
        },
        {
          "schema": "extensions",
          "name": "pgp_pub_encrypt_bytea",
          "type": "FUNCTION",
          "arguments": "bytea, bytea",
          "return_type": "bytea",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_pub_encrypt_bytea"
        },
        {
          "schema": "extensions",
          "name": "pgp_pub_encrypt_bytea",
          "type": "FUNCTION",
          "arguments": "bytea, bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_pub_encrypt_bytea"
        },
        {
          "schema": "extensions",
          "name": "pgp_sym_decrypt",
          "type": "FUNCTION",
          "arguments": "bytea, text, text",
          "return_type": "text",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_sym_decrypt_text"
        },
        {
          "schema": "extensions",
          "name": "pgp_sym_decrypt",
          "type": "FUNCTION",
          "arguments": "bytea, text",
          "return_type": "text",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_sym_decrypt_text"
        },
        {
          "schema": "extensions",
          "name": "pgp_sym_decrypt_bytea",
          "type": "FUNCTION",
          "arguments": "bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_sym_decrypt_bytea"
        },
        {
          "schema": "extensions",
          "name": "pgp_sym_decrypt_bytea",
          "type": "FUNCTION",
          "arguments": "bytea, text, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_sym_decrypt_bytea"
        },
        {
          "schema": "extensions",
          "name": "pgp_sym_encrypt",
          "type": "FUNCTION",
          "arguments": "text, text, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_sym_encrypt_text"
        },
        {
          "schema": "extensions",
          "name": "pgp_sym_encrypt",
          "type": "FUNCTION",
          "arguments": "text, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_sym_encrypt_text"
        },
        {
          "schema": "extensions",
          "name": "pgp_sym_encrypt_bytea",
          "type": "FUNCTION",
          "arguments": "bytea, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_sym_encrypt_bytea"
        },
        {
          "schema": "extensions",
          "name": "pgp_sym_encrypt_bytea",
          "type": "FUNCTION",
          "arguments": "bytea, text, text",
          "return_type": "bytea",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgp_sym_encrypt_bytea"
        },
        {
          "schema": "extensions",
          "name": "pgrst_ddl_watch",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "event_trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    ...[truncated]"
        },
        {
          "schema": "extensions",
          "name": "pgrst_drop_watch",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "event_trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; "
        },
        {
          "schema": "extensions",
          "name": "set_graphql_placeholder",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "event_trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": "Reintroduces placeholder function for graphql_public.graphql",
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n...[truncated]"
        },
        {
          "schema": "extensions",
          "name": "uuid_generate_v1",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "uuid",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "uuid_generate_v1"
        },
        {
          "schema": "extensions",
          "name": "uuid_generate_v1mc",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "uuid",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "uuid_generate_v1mc"
        },
        {
          "schema": "extensions",
          "name": "uuid_generate_v3",
          "type": "FUNCTION",
          "arguments": "namespace uuid, name text",
          "return_type": "uuid",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "uuid_generate_v3"
        },
        {
          "schema": "extensions",
          "name": "uuid_generate_v4",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "uuid",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "uuid_generate_v4"
        },
        {
          "schema": "extensions",
          "name": "uuid_generate_v5",
          "type": "FUNCTION",
          "arguments": "namespace uuid, name text",
          "return_type": "uuid",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "uuid_generate_v5"
        },
        {
          "schema": "extensions",
          "name": "uuid_nil",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "uuid",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "uuid_nil"
        },
        {
          "schema": "extensions",
          "name": "uuid_ns_dns",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "uuid",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "uuid_ns_dns"
        },
        {
          "schema": "extensions",
          "name": "uuid_ns_oid",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "uuid",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "uuid_ns_oid"
        },
        {
          "schema": "extensions",
          "name": "uuid_ns_url",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "uuid",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "uuid_ns_url"
        },
        {
          "schema": "extensions",
          "name": "uuid_ns_x500",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "uuid",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "uuid_ns_x500"
        },
        {
          "schema": "graphql",
          "name": "_internal_resolve",
          "type": "FUNCTION",
          "arguments": "query text, variables jsonb, \"operationName\" text, extensions jsonb",
          "return_type": "jsonb",
          "language": "c",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "resolve_wrapper"
        },
        {
          "schema": "graphql",
          "name": "comment_directive",
          "type": "FUNCTION",
          "arguments": "comment_ text",
          "return_type": "jsonb",
          "language": "sql",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n"
        },
        {
          "schema": "graphql",
          "name": "exception",
          "type": "FUNCTION",
          "arguments": "message text",
          "return_type": "text",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n"
        },
        {
          "schema": "graphql",
          "name": "get_schema_version",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "integer",
          "language": "sql",
          "volatility": "VOLATILE",
          "security_definer": true,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n    select last_value from graphql.seq_schema_version;\n"
        },
        {
          "schema": "graphql",
          "name": "increment_schema_version",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "event_trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": true,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nbegin\n    perform pg_catalog.nextval('graphql.seq_schema_version');\nend;\n"
        },
        {
          "schema": "graphql",
          "name": "resolve",
          "type": "FUNCTION",
          "arguments": "query text, variables jsonb, \"operationName\" text, extensions jsonb",
          "return_type": "jsonb",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n             ...[truncated]"
        },
        {
          "schema": "graphql_public",
          "name": "graphql",
          "type": "FUNCTION",
          "arguments": "\"operationName\" text, query text, variables jsonb, extensions jsonb",
          "return_type": "jsonb",
          "language": "sql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        "
        },
        {
          "schema": "pgbouncer",
          "name": "get_auth",
          "type": "FUNCTION",
          "arguments": "p_usename text",
          "return_type": "TABLE(username text, password text)",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": true,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nbegin\n    raise debug 'PgBouncer auth request: %', p_usename;\n\n    return query\n    select \n        rolname::text, \n        case when rolvaliduntil < now() \n            then null \n            else rolpassword::text \n        end \n    from pg_authid \n    where rolname=$1 and rolcanlogin;\nend;\n"
        },
        {
          "schema": "public",
          "name": "calcular_metas_clientes",
          "type": "FUNCTION",
          "arguments": "p_ano_base integer, p_ano_meta integer",
          "return_type": "TABLE(clientes_processados integer, metas_minimas integer, metas_crescimento integer, valor_total_metas numeric)",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nDECLARE\r\n    v_meta_minima CONSTANT NUMERIC := 12000.00;\r\n    v_percentual_crescimento CONSTANT NUMERIC := 0.10; -- 10%\r\n    v_total_processados INTEGER := 0;\r\n    v_total_minimas INTEGER := 0;\r\n    v_total_crescimento INTEGER := 0;\r\n    v_soma_metas NUMERIC := 0;\r\nBEGIN\r\n    -- Limpar metas antigas do mesmo ano\r\n    DELETE FROM meta_compra_cliente WHERE ano_meta = p_ano_meta;\r\n    \r\n    -- Inserir novas metas\r\n    INSERT INTO meta_compra_cliente (\r\n        codigo_cliente,\r\n        nome_client...[truncated]"
        },
        {
          "schema": "public",
          "name": "calcular_mix_ideal_clientes",
          "type": "FUNCTION",
          "arguments": "p_meses_analise integer",
          "return_type": "TABLE(clientes_analisados integer, marcas_distintas integer, combinacoes_geradas integer)",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nDECLARE\r\n    v_data_inicial DATE;\r\n    v_data_final DATE;\r\n    v_clientes INTEGER := 0;\r\n    v_marcas INTEGER := 0;\r\n    v_combinacoes INTEGER := 0;\r\nBEGIN\r\n    -- Definir período de análise\r\n    v_data_final := CURRENT_DATE;\r\n    v_data_inicial := v_data_final - INTERVAL '1 month' * p_meses_analise;\r\n    \r\n    -- Limpar dados antigos do mesmo período\r\n    DELETE FROM mix_ideal_cliente \r\n    WHERE periodo_inicial = v_data_inicial \r\n      AND periodo_final = v_data_final;\r\n    \r\n    -- Inserir ...[truncated]"
        },
        {
          "schema": "public",
          "name": "corrigir_cidades_encoding",
          "type": "FUNCTION",
          "arguments": "texto text",
          "return_type": "text",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nBEGIN\r\n    IF texto IS NULL THEN RETURN NULL; END IF;\r\n    \r\n    -- O padrão encontrado: 239, 191, 189 = EF BF BD =   (replacement character)\r\n    -- Isso geralmente substitui caracteres acentuados mal codificados\r\n    \r\n    -- Baseado nos nomes das cidades, vamos fazer substituições contextuais\r\n    \r\n    -- \"São\" no início\r\n    IF texto LIKE 'S o %' THEN\r\n        texto := REPLACE(texto, 'S o', 'São');\r\n    END IF;\r\n    \r\n    -- \"ção\" no final ou meio\r\n    texto := REPLACE(texto, '  o', 'ção'...[truncated]"
        },
        {
          "schema": "public",
          "name": "corrigir_encoding",
          "type": "FUNCTION",
          "arguments": "texto text",
          "return_type": "text",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nBEGIN\r\n    IF texto IS NULL THEN RETURN NULL; END IF;\r\n    \r\n    -- Correções mais comuns no português brasileiro\r\n    texto := REPLACE(texto, 'Ã¡', 'á');\r\n    texto := REPLACE(texto, 'Ã ', 'à');\r\n    texto := REPLACE(texto, 'Ã¢', 'â');\r\n    texto := REPLACE(texto, 'Ã£', 'ã');\r\n    texto := REPLACE(texto, 'Ã©', 'é');\r\n    texto := REPLACE(texto, 'Ãª', 'ê');\r\n    texto := REPLACE(texto, 'Ã­', 'í');\r\n    texto := REPLACE(texto, 'Ã³', 'ó');\r\n    texto := REPLACE(texto, 'Ã´', 'ô');\r\n    texto := R...[truncated]"
        },
        {
          "schema": "public",
          "name": "corrigir_encoding_generico",
          "type": "FUNCTION",
          "arguments": "texto text",
          "return_type": "text",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nDECLARE\r\n    texto_corrigido TEXT;\r\nBEGIN\r\n    IF texto IS NULL THEN RETURN NULL; END IF;\r\n    \r\n    texto_corrigido := texto;\r\n    \r\n    -- Substituições mais comuns para cidades brasileiras\r\n    -- Padrão: caractere antes do   geralmente indica o tipo de acento\r\n    \r\n    -- a  -> á\r\n    texto_corrigido := regexp_replace(texto_corrigido, 'a ', 'á', 'g');\r\n    texto_corrigido := regexp_replace(texto_corrigido, 'A ', 'Á', 'g');\r\n    \r\n    -- e  -> é ou ê\r\n    texto_corrigido := regexp_replace(...[truncated]"
        },
        {
          "schema": "public",
          "name": "create_user_with_metadata",
          "type": "FUNCTION",
          "arguments": "email text, password text, user_metadata jsonb",
          "return_type": "void",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": true,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nDECLARE\r\n  user_id uuid;\r\nBEGIN\r\n  -- Cria o usuário\r\n  INSERT INTO auth.users (\r\n    email,\r\n    encrypted_password,\r\n    email_confirmed_at,\r\n    raw_user_meta_data,\r\n    created_at,\r\n    updated_at\r\n  ) VALUES (\r\n    email,\r\n    crypt(password, gen_salt('bf')),\r\n    NOW(),\r\n    user_metadata,\r\n    NOW(),\r\n    NOW()\r\n  ) RETURNING id INTO user_id;\r\n  \r\n  -- Cria a identidade\r\n  INSERT INTO auth.identities (\r\n    user_id,\r\n    provider_id,\r\n    provider,\r\n    identity_data,\r\n    created_at,\r\n...[truncated]"
        },
        {
          "schema": "public",
          "name": "debug_auth_context",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "json",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": true,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nDECLARE\r\n    v_result json;\r\nBEGIN\r\n    SELECT json_build_object(\r\n        'auth_uid', auth.uid(),\r\n        'auth_role', auth.role(),\r\n        'auth_email', auth.email(),\r\n        'jwt_claims', current_setting('request.jwt.claims', true)::json,\r\n        'current_user', current_user,\r\n        'session_user', session_user\r\n    ) INTO v_result;\r\n    \r\n    RETURN v_result;\r\nEND;\r\n"
        },
        {
          "schema": "public",
          "name": "extrair_codigo_vendedor",
          "type": "FUNCTION",
          "arguments": "vendedor_text text",
          "return_type": "integer",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nBEGIN\r\n    RETURN CAST(SPLIT_PART(vendedor_text, ' - ', 1) AS INTEGER);\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        RETURN NULL;\r\nEND;\r\n"
        },
        {
          "schema": "public",
          "name": "fix_encoding_manual",
          "type": "FUNCTION",
          "arguments": "input_text text",
          "return_type": "text",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nBEGIN\r\n    IF input_text IS NULL THEN\r\n        RETURN NULL;\r\n    END IF;\r\n    \r\n    -- Substitui os padrões mais comuns\r\n    input_text := REPLACE(input_text, 'Ã¡', 'á');\r\n    input_text := REPLACE(input_text, 'Ã£', 'ã');\r\n    input_text := REPLACE(input_text, 'Ã§', 'ç');\r\n    -- ... (resto das substituições)\r\n    \r\n    RETURN input_text;\r\nEND;\r\n"
        },
        {
          "schema": "public",
          "name": "get_cliente_detalhes",
          "type": "FUNCTION",
          "arguments": "p_codigo_cliente integer",
          "return_type": "TABLE(codigo_cliente integer, nome_fantasia text, razao_social text, cnpj text, inscricao_estadual text, endereco text, bairro text, cidade text, estado text, cep text, telefone text, celular text, email text, rota text, status_code text, valor_limite_credito numeric, dias_sem_comprar integer, valor_vendas_2024 numeric, valor_vendas_2025 numeric, meta_2025 numeric, percentual_atingimento integer, estrelas integer, acao_recomendada text, qtd_compras_2024 integer, qtd_compras_2025 integer, produtos_comprados jsonb)",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        c.codigo_cliente,\r\n        c.nome_fantasia,\r\n        c.razao_social,\r\n        ''::text,  -- cnpj\r\n        ''::text,  -- inscricao_estadual\r\n        ''::text,  -- endereco\r\n        COALESCE(c.bairro, ''),\r\n        c.cidade,\r\n        COALESCE(tc.estado, ''),\r\n        COALESCE(tc.cep, ''),\r\n        COALESCE(tc.celular, ''),  -- telefone\r\n        COALESCE(tc.celular, ''),\r\n        ''::text,  -- email\r\n        COALESCE(c.rota, 'SEM ROTA'),\r\n        c.st...[truncated]"
        },
        {
          "schema": "public",
          "name": "handle_new_user",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": true,
          "comment": null,
          "trigger_count": 1,
          "triggers": "on_auth_user_created ON users",
          "source_preview": "\nBEGIN\n  -- Your function logic here\n  INSERT INTO public.profiles (id, email)\n  VALUES (NEW.id, NEW.email);\n  RETURN NEW;\nEND;\n"
        },
        {
          "schema": "public",
          "name": "truncate_titulos_vencidos",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "void",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": true,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\r\nBEGIN\r\n  TRUNCATE TABLE titulos_vencidos RESTART IDENTITY;\r\nEND;\r\n"
        },
        {
          "schema": "public",
          "name": "update_updated_at_column",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 2,
          "triggers": "update_analise_rfm_updated_at ON analise_rfm, update_compras_produto_cliente_updated_at ON compras_produto_cliente",
          "source_preview": "\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n"
        },
        {
          "schema": "realtime",
          "name": "apply_rls",
          "type": "FUNCTION",
          "arguments": "wal jsonb, max_record_bytes integer",
          "return_type": "SETOF realtime.wal_rls",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions...[truncated]"
        },
        {
          "schema": "realtime",
          "name": "broadcast_changes",
          "type": "FUNCTION",
          "arguments": "topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text",
          "return_type": "void",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table',...[truncated]"
        },
        {
          "schema": "realtime",
          "name": "build_prepared_statement_sql",
          "type": "FUNCTION",
          "arguments": "prepared_statement_name text, entity regclass, columns realtime.wal_column[]",
          "return_type": "text",
          "language": "sql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || enti...[truncated]"
        },
        {
          "schema": "realtime",
          "name": "cast",
          "type": "FUNCTION",
          "arguments": "val text, type_ regtype",
          "return_type": "jsonb",
          "language": "plpgsql",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    "
        },
        {
          "schema": "realtime",
          "name": "check_equality_op",
          "type": "FUNCTION",
          "arguments": "op realtime.equality_op, type_ regtype, val_1 text, val_2 text",
          "return_type": "boolean",
          "language": "plpgsql",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else ...[truncated]"
        },
        {
          "schema": "realtime",
          "name": "is_visible_through_filters",
          "type": "FUNCTION",
          "arguments": "columns realtime.wal_column[], filters realtime.user_defined_filter[]",
          "return_type": "boolean",
          "language": "sql",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n     ...[truncated]"
        },
        {
          "schema": "realtime",
          "name": "list_changes",
          "type": "FUNCTION",
          "arguments": "publication name, slot_name name, max_changes integer, max_record_bytes integer",
          "return_type": "SETOF realtime.wal_rls",
          "language": "sql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablen...[truncated]"
        },
        {
          "schema": "realtime",
          "name": "quote_wal2json",
          "type": "FUNCTION",
          "arguments": "entity regclass",
          "return_type": "text",
          "language": "sql",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)...[truncated]"
        },
        {
          "schema": "realtime",
          "name": "send",
          "type": "FUNCTION",
          "arguments": "payload jsonb, event text, topic text, private boolean",
          "return_type": "void",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      PERFORM pg_notify(\n          'realtime:system',\n          jsonb_build_object(\n              'error', SQLERRM,\n              'function', 'r...[truncated]"
        },
        {
          "schema": "realtime",
          "name": "subscription_check_filters",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 1,
          "triggers": "tr_check_filters ON subscription",
          "source_preview": "\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::...[truncated]"
        },
        {
          "schema": "realtime",
          "name": "to_regrole",
          "type": "FUNCTION",
          "arguments": "role_name text",
          "return_type": "regrole",
          "language": "sql",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": " select role_name::regrole "
        },
        {
          "schema": "realtime",
          "name": "topic",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "text",
          "language": "sql",
          "volatility": "STABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nselect nullif(current_setting('realtime.topic', true), '')::text;\n"
        },
        {
          "schema": "storage",
          "name": "can_insert_object",
          "type": "FUNCTION",
          "arguments": "bucketid text, name text, owner uuid, metadata jsonb",
          "return_type": "void",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n"
        },
        {
          "schema": "storage",
          "name": "extension",
          "type": "FUNCTION",
          "arguments": "name text",
          "return_type": "text",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nDECLARE\n_parts text[];\n_filename text;\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\tselect _parts[array_length(_parts,1)] into _filename;\n\t-- @todo return the last part instead of 2\n\treturn reverse(split_part(reverse(_filename), '.', 1));\nEND\n"
        },
        {
          "schema": "storage",
          "name": "filename",
          "type": "FUNCTION",
          "arguments": "name text",
          "return_type": "text",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n"
        },
        {
          "schema": "storage",
          "name": "foldername",
          "type": "FUNCTION",
          "arguments": "name text",
          "return_type": "text[]",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[1:array_length(_parts,1)-1];\nEND\n"
        },
        {
          "schema": "storage",
          "name": "get_size_by_bucket",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "TABLE(size bigint, bucket_id text)",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nBEGIN\n    return query\n        select sum((metadata->>'size')::int) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n"
        },
        {
          "schema": "storage",
          "name": "list_multipart_uploads_with_delimiter",
          "type": "FUNCTION",
          "arguments": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text",
          "return_type": "TABLE(key text, id text, created_at timestamp with time zone)",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE...[truncated]"
        },
        {
          "schema": "storage",
          "name": "list_objects_with_delimiter",
          "type": "FUNCTION",
          "arguments": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text",
          "return_type": "TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WH...[truncated]"
        },
        {
          "schema": "storage",
          "name": "operation",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "text",
          "language": "plpgsql",
          "volatility": "STABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n"
        },
        {
          "schema": "storage",
          "name": "search",
          "type": "FUNCTION",
          "arguments": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
          "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
          "language": "plpgsql",
          "volatility": "STABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\ndeclare\n  v_order_by text;\n  v_sort_order text;\nbegin\n  case\n    when sortcolumn = 'name' then\n      v_order_by = 'name';\n    when sortcolumn = 'updated_at' then\n      v_order_by = 'updated_at';\n    when sortcolumn = 'created_at' then\n      v_order_by = 'created_at';\n    when sortcolumn = 'last_accessed_at' then\n      v_order_by = 'last_accessed_at';\n    else\n      v_order_by = 'name';\n  end case;\n\n  case\n    when sortorder = 'asc' then\n      v_sort_order = 'asc';\n    when sortorder = 'desc' th...[truncated]"
        },
        {
          "schema": "storage",
          "name": "update_updated_at_column",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "trigger",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 1,
          "triggers": "update_objects_updated_at ON objects",
          "source_preview": "\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n"
        },
        {
          "schema": "vault",
          "name": "_crypto_aead_det_decrypt",
          "type": "FUNCTION",
          "arguments": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgsodium_crypto_aead_det_decrypt_by_id"
        },
        {
          "schema": "vault",
          "name": "_crypto_aead_det_encrypt",
          "type": "FUNCTION",
          "arguments": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgsodium_crypto_aead_det_encrypt_by_id"
        },
        {
          "schema": "vault",
          "name": "_crypto_aead_det_noncegen",
          "type": "FUNCTION",
          "arguments": "",
          "return_type": "bytea",
          "language": "c",
          "volatility": "IMMUTABLE",
          "security_definer": false,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "pgsodium_crypto_aead_det_noncegen"
        },
        {
          "schema": "vault",
          "name": "create_secret",
          "type": "FUNCTION",
          "arguments": "new_secret text, new_name text, new_description text, new_key_id uuid",
          "return_type": "uuid",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": true,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nDECLARE\n  rec record;\nBEGIN\n  INSERT INTO vault.secrets (secret, name, description)\n  VALUES (\n    new_secret,\n    new_name,\n    new_description\n  )\n  RETURNING * INTO rec;\n  UPDATE vault.secrets s\n  SET secret = encode(vault._crypto_aead_det_encrypt(\n    message := convert_to(rec.secret, 'utf8'),\n    additional := convert_to(s.id::text, 'utf8'),\n    key_id := 0,\n    context := 'pgsodium'::bytea,\n    nonce := rec.nonce\n  ), 'base64')\n  WHERE id = rec.id;\n  RETURN rec.id;\nEND\n"
        },
        {
          "schema": "vault",
          "name": "update_secret",
          "type": "FUNCTION",
          "arguments": "secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid",
          "return_type": "void",
          "language": "plpgsql",
          "volatility": "VOLATILE",
          "security_definer": true,
          "comment": null,
          "trigger_count": 0,
          "triggers": "",
          "source_preview": "\nDECLARE\n  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);\nBEGIN\n  UPDATE vault.secrets s\n  SET\n    secret = CASE WHEN new_secret IS NULL THEN s.secret\n                  ELSE encode(vault._crypto_aead_det_encrypt(\n                    message := convert_to(new_secret, 'utf8'),\n                    additional := convert_to(s.id::text, 'utf8'),\n                    key_id := 0,\n                    context := 'pgsodium'::bytea,\n                    ...[truncated]"
        }
      ]
    }
  }
]